# frozen_string_literal: true

require 'rails_helper'

RSpec.describe <%= [@route_scope_class, @scope_class].reject { |c| c.empty? }.join("::") %>Controller, type: :controller do
<% if @resource_owner_id.present? -%>
  let(:owner) { create(:<%= @resource_owner %>) }
  let(:actor) { create(:actor) }
<% end -%>

  let(:valid_attributes) do
    {
<% @fields.each_with_index do |(field, type), index| -%>
<% next if field.to_s == 'id' || field.to_s.end_with?('_id') -%>
      <%= field %>: <%= case type.to_s
        when 'string' then "'Sample #{field}'"
        when 'text' then "'Sample text for #{field}'"
        when 'integer' then '1'
        when 'float', 'decimal' then '1.5'
        when 'boolean' then 'true'
        when 'date' then 'Date.today'
        when 'datetime' then 'Time.current'
        else "'value'"
      end %><%= ',' unless index == @fields.size - 1 %>
<% end -%>
    }
  end

  let(:invalid_attributes) do
    {
<% @fields.first(2).each_with_index do |(field, type), index| -%>
<% next if field.to_s == 'id' || field.to_s.end_with?('_id') -%>
      <%= field %>: nil<%= ',' unless index == 1 %>
<% end -%>
    }
  end

<% if @resource_owner_id.present? -%>
  before do
    allow(controller).to receive(:<%= @resource_owner_id %>).and_return(owner.id)
  end

<% end -%>
  describe 'GET #index' do
    context 'when use case succeeds' do
      let(:<%= @variable_subject.pluralize %>) { create_list(:<%= @variable_subject %>) }
      let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>) }
      let(:success_result) { Dry::Monads::Success(<%= @variable_subject.pluralize %>) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(success_result)
      end

      it 'returns success response and assigns @<%= @variable_subject.pluralize %>' do
        get :index

        expect(response).to have_http_status(:success)
        expect(assigns(:<%= @variable_subject.pluralize %>)).to eq(<%= @variable_subject.pluralize %>)
        expect(response).to render_template('<%= [@route_scope_path, @scope_path, 'index'].reject { |c| c.empty? }.join("/") %>')
      end

      it 'calls use case with correct contract' do
        expect(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!)<%= @resource_owner_id.present? ? "\n          .with(hash_including(#{@resource_owner_id}: owner.id))" : '' %>

        get :index
      end
    end

    context 'when use case fails' do
      let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>) }
      let(:failure_result) { Dry::Monads::Failure('Error loading <%= @variable_subject.pluralize %>') }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('list')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(failure_result)
      end

      it 'redirects to root path with error' do
        get :index

        expect(response).to redirect_to(root_path)
        expect(flash[:success]).to eq('Error loading <%= @variable_subject.pluralize %>')
      end
    end
  end

  describe 'GET #show' do
    let(:<%= @variable_subject %>) { create(:<%= @variable_subject %><%= @resource_owner_id.present? ? ", #{@resource_owner_id}: owner.id" : '' %>) }

    context 'when use case succeeds' do
      let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>) }
      let(:success_result) { Dry::Monads::Success(<%= @variable_subject %>) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(success_result)
      end

      it 'returns success response and assigns @<%= @variable_subject %>' do
        get :show, params: { id: <%= @variable_subject %>.id }

        expect(response).to have_http_status(:success)
        expect(assigns(:<%= @variable_subject %>)).to eq(<%= @variable_subject %>)
      end

      it 'calls use case with correct contract' do
        expect(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!)
          .with(hash_including(<%= @resource_owner_id.present? ? "#{@resource_owner_id}: owner.id, " : '' %>id: <%= @variable_subject %>.id))

        get :show, params: { id: <%= @variable_subject %>.id }
      end
    end

    context 'when use case fails' do
      let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>) }
      let(:failure_result) { Dry::Monads::Failure('<%= @subject_class %> not found') }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('fetch', '_by_id')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(failure_result)
      end

      it 'redirects to root path with error' do
        get :show, params: { id: 'non-existent' }

        expect(response).to redirect_to(root_path)
        expect(flash[:success]).to eq('<%= @subject_class %> not found')
      end
    end
  end

  describe 'GET #new' do
    it 'returns success response and assigns new <%= @variable_subject %>' do
      get :new

      expect(response).to have_http_status(:success)
      expect(assigns(:<%= @variable_subject %>)).to be_a_new(<%= @model_class %>)
    end
  end

  describe 'GET #edit' do
    let(:<%= @variable_subject %>) { create(:<%= @variable_subject %><%= @resource_owner_id.present? ? ", #{@resource_owner_id}: owner.id" : '' %>) }

    context 'when <%= @variable_subject %> exists<%= @resource_owner_id.present? ? " and belongs to owner" : '' %>' do
      before do
        allow(<%= @model_class %>).to receive(:find_by)
          .with(<%= @resource_owner_id.present? ? "id: #{@variable_subject}.id, #{@resource_owner_id}: owner.id" : "id: #{@variable_subject}.id" %>)
          .and_return(<%= @variable_subject %>)
      end

      it 'returns success response and assigns <%= @variable_subject %>' do
        get :edit, params: { id: <%= @variable_subject %>.id }

        expect(response).to have_http_status(:success)
        expect(assigns(:<%= @variable_subject %>)).to eq(<%= @variable_subject %>)
      end
    end

    context 'when <%= @variable_subject %> does not exist<%= @resource_owner_id.present? ? " or does not belong to owner" : '' %>' do
      before do
        allow(<%= @model_class %>).to receive(:find_by)
          .with(<%= @resource_owner_id.present? ? "id: 'non-existent', #{@resource_owner_id}: owner.id" : "id: 'non-existent'" %>)
          .and_return(nil)
      end

      it 'redirects with error' do
        get :edit, params: { id: 'non-existent' }

        expect(response).to redirect_to(<%= [@route_scope_path, @scope_path].reject { |c| c.empty? }.join("_") %>_url)
        expect(flash[:error]).to eq('<%= @subject_class %> not found.')
      end
    end
  end

  describe 'POST #create' do
    let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>) }

    context 'with valid params' do
      let(:created_<%= @variable_subject %>) { build(:<%= @variable_subject %>, id: 'uuid-123', **valid_attributes) }
      let(:success_result) { Dry::Monads::Success(created_<%= @variable_subject %>) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(success_result)
      end

      it 'creates and redirects with success message' do
        post :create, params: { models_<%= @subject_class.underscore %>: valid_attributes }

        expect(response).to redirect_to(<%= [@route_scope_path, @scope_path.singularize].reject { |c| c.empty? }.join("_") %>_url(id: created_<%= @variable_subject %>.id))
        expect(flash[:success]).to eq('<%= @subject_class %> was successfully created.')
      end

      it 'calls use case with correct contract' do
        expect(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!)
          .with(hash_including(<%= @resource_owner_id.present? ? "#{@resource_owner_id}: owner.id, " : '' %>**valid_attributes.stringify_keys))

        post :create, params: { models_<%= @subject_class.underscore %>: valid_attributes }
      end
    end

    context 'with invalid params' do
      let(:errors) { { <%= @fields.first.first %>: ['cannot be blank'] } }
      let(:failure_result) { Dry::Monads::Failure(errors) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('create')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(failure_result)
        allow(controller).to receive(:build_form_errors).and_return(<%= @model_class %>.new)
      end

      it 'does not create and renders new with errors' do
        post :create, params: { models_<%= @subject_class.underscore %>: invalid_attributes }

        expect(response).to have_http_status(:unprocessable_entity)
        expect(response).to render_template('<%= [@route_scope_path, @scope_path, 'new'].reject { |c| c.empty? }.join("/") %>')
        expect(assigns(:<%= @variable_subject %>)).to be_a(<%= @model_class %>)
      end

      it 'calls build_form_errors with correct parameters' do
        expect(controller).to receive(:build_form_errors)
          .with(anything, an_instance_of(<%= @model_class %>), errors)

        post :create, params: { models_<%= @subject_class.underscore %>: invalid_attributes }
      end
    end
  end

  describe 'PATCH #update' do
    let(:<%= @variable_subject %>) { create(:<%= @variable_subject %><%= @resource_owner_id.present? ? ", #{@resource_owner_id}: owner.id" : '' %>) }
    let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>) }
    let(:updated_attributes) { { <%= @fields.first.first %>: 'Updated Value' } }

    before do
      allow(<%= @model_class %>).to receive(:find_by)
        .with(<%= @resource_owner_id.present? ? "id: #{@variable_subject}.id, #{@resource_owner_id}: owner.id" : "id: #{@variable_subject}.id" %>)
        .and_return(<%= @variable_subject %>)
    end

    context 'with valid params' do
      let(:updated_<%= @variable_subject %>) { <%= @variable_subject %>.tap { |obj| obj.<%= @fields.first.first %> = 'Updated Value' } }
      let(:success_result) { Dry::Monads::Success(updated_<%= @variable_subject %>) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(success_result)
      end

      it 'updates and redirects with success message' do
        patch :update, params: { id: <%= @variable_subject %>.id, models_<%= @subject_class.underscore %>: updated_attributes }

        expect(response).to redirect_to(<%= [@route_scope_path, @scope_path.singularize].reject { |c| c.empty? }.join("_") %>_url(id: <%= @variable_subject %>.id))
        expect(flash[:success]).to eq('<%= @subject_class %> was successfully updated.')
      end

      it 'calls use case with correct contract' do
        expect(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!)
          .with(hash_including(<%= @resource_owner_id.present? ? "#{@resource_owner_id}: owner.id, " : '' %>id: <%= @variable_subject %>.id, **updated_attributes.stringify_keys))

        patch :update, params: { id: <%= @variable_subject %>.id, models_<%= @subject_class.underscore %>: updated_attributes }
      end
    end

    context 'with invalid params' do
      let(:errors) { { <%= @fields.first.first %>: ['cannot be blank'] } }
      let(:failure_result) { Dry::Monads::Failure(errors) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('update')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(failure_result)
        allow(<%= @model_class %>).to receive(:find).with(<%= @variable_subject %>.id).and_return(<%= @variable_subject %>)
        allow(controller).to receive(:build_form_errors).and_return(<%= @variable_subject %>)
      end

      it 'does not update and renders edit with errors' do
        patch :update, params: { id: <%= @variable_subject %>.id, models_<%= @subject_class.underscore %>: invalid_attributes }

        expect(response).to have_http_status(:unprocessable_entity)
        expect(response).to render_template('<%= [@route_scope_path, @scope_path, 'edit'].reject { |c| c.empty? }.join("/") %>')
        expect(assigns(:<%= @variable_subject %>)).to eq(<%= @variable_subject %>)
      end
    end
  end

  describe 'DELETE #destroy' do
    let(:<%= @variable_subject %>) { create(:<%= @variable_subject %><%= @resource_owner_id.present? ? ", #{@resource_owner_id}: owner.id" : '' %>) }
    let(:use_case_instance) { instance_double(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>) }

    context 'when deletion succeeds' do
      let(:success_result) { Dry::Monads::Success(true) }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(success_result)
      end

      it 'destroys and redirects with success notice' do
        delete :destroy, params: { id: <%= @variable_subject %>.id }

        expect(response).to redirect_to(<%= [@route_scope_path, @scope_path].reject { |c| c.empty? }.join("_") %>_url)
        expect(flash[:notice]).to eq('<%= @subject_class %> was successfully destroyed.')
      end

      it 'calls use case with correct contract' do
        expect(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!)
          .with(hash_including(<%= @resource_owner_id.present? ? "#{@resource_owner_id}: owner.id, " : '' %>id: <%= @variable_subject %>.id))

        delete :destroy, params: { id: <%= @variable_subject %>.id }
      end
    end

    context 'when deletion fails' do
      let(:failure_result) { Dry::Monads::Failure('Cannot delete <%= @variable_subject %>') }

      before do
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>).to receive(:contract!).and_return(true)
        allow(Core::UseCases::<%= [@route_scope_class, @scope_class, build_usecase_filename('destroy')].reject { |c| c.empty? }.join("::") %>).to receive(:new).and_return(use_case_instance)
        allow(use_case_instance).to receive(:result).and_return(failure_result)
      end

      it 'redirects with error message' do
        delete :destroy, params: { id: <%= @variable_subject %>.id }

        expect(response).to redirect_to(<%= [@route_scope_path, @scope_path].reject { |c| c.empty? }.join("_") %>_url)
        expect(flash[:error]).to eq('<%= @subject_class %> could not be destroyed.')
      end
    end
  end

  describe 'private methods' do
    describe '#build_contract' do
      it 'merges <%= @resource_owner_id.present? ? "#{@resource_owner_id} " : '' %>with params' do
        params = { <%= @fields.first.first %>: 'Test' }
        result = controller.send(:build_contract, params)

        expect(result).to include(<%= @resource_owner_id.present? ? "#{@resource_owner_id}: owner.id, " : '' %><%= @fields.first.first %>: 'Test')
      end
    end

    describe '#set_<%= @variable_subject %>' do
      context 'when <%= @variable_subject %> exists' do
        let(:<%= @variable_subject %>) { create(:<%= @variable_subject %><%= @resource_owner_id.present? ? ", #{@resource_owner_id}: owner.id" : '' %>) }

        before do
          allow(<%= @model_class %>).to receive(:find_by)
            .with(<%= @resource_owner_id.present? ? "id: #{@variable_subject}.id, #{@resource_owner_id}: owner.id" : "id: #{@variable_subject}.id" %>)
            .and_return(<%= @variable_subject %>)
        end

        it 'sets @<%= @variable_subject %>' do
          controller.params[:id] = <%= @variable_subject %>.id
          controller.send(:set_<%= @variable_subject %>)

          expect(assigns(:<%= @variable_subject %>)).to eq(<%= @variable_subject %>)
          expect(response).not_to be_redirect
        end
      end

      context 'when <%= @variable_subject %> does not exist' do
        before do
          allow(<%= @model_class %>).to receive(:find_by)
            .with(<%= @resource_owner_id.present? ? "id: 'non-existent', #{@resource_owner_id}: owner.id" : "id: 'non-existent'" %>)
            .and_return(nil)
        end

        it 'redirects with error' do
          controller.params[:id] = 'non-existent'
          controller.send(:set_<%= @variable_subject %>)

          expect(response).to redirect_to(<%= [@route_scope_path, @scope_path].reject { |c| c.empty? }.join("_") %>_url)
          expect(flash[:error]).to eq('<%= @subject_class %> not found.')
        end
      end
    end

    describe '#<%= @variable_subject %>_params' do
      it 'permits correct attributes' do
        params = ActionController::Parameters.new(
          models_<%= @subject_class.underscore %>: valid_attributes
        )
        allow(controller).to receive(:params).and_return(params)

        permitted = controller.send(:<%= @variable_subject %>_params)
        expect(permitted).to be_permitted
      end
    end
  end
end
